
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{epstopdf}


%\usepackage[german]{babel}
\usepackage[]{algorithmic}
\usepackage[]{algorithm}
\usepackage{multirow}

%\usepackage{amsthm}

\usepackage{url}
\urldef{\mailsa}\path|zheng.haitao@sz.tsinghua.edu.cn|
\urldef{\mailsb}\path|lizhuo13@mails.tsinghua.edu.cn|
%\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}
\floatname{algorithm}{Algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\begin{document}

\mainmatter % start of an individual contribution

% first the title is needed
\title{iCHUM: An Efficient Algorithm for High Utility Mining in Incremental Databases}

% a short form should be given in case it is too long for the running head
\titlerunning{iCHUM: High Utility Mining in Incremental Databases}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Hai-Tao Zheng%
%\thanks{Tel.: +8675526036076; fax: +8675526036761}%
\and ZHuo Li}
%
\authorrunning{iCHUM: High Utility Mining in Incremental Databases}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Graduate School at Shenzhen, Tsinghua University, \\
Building H,Tsinghua Campus,University Town,Shenzhen, China\\
\mailsa\\
\mailsb\\}
%\mailsc\\

%\url{http://www.springer.com/lncs}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{iCHUM: An Efficient Algorithm for High Utility Mining in Incremental Databases}
\tocauthor{Hai-Tao Zheng and ZHuo Li}
\maketitle


\begin{abstract}
High utility mining is a fundamental topic in association rule, which aims to discover all itemsets with high utility from transaction database. Although a number of related methods have been proposed in recent years, they suffer from inefficiency in the incremental databases mining due to reconstruction of the whole data structure. In this paper, we propose our iCHUM-Tree and iCHUM algorithm to address the problem. The iCHUM algorithm maintains necessary items for mining procedure. And it reuse data structure from previous database and update iCHUM-Tree under incremental database environment. Performace analysis shows that our tree structre is efficient for high utility mining in incremental databases.
%\emph{abstract} environment.
%141 words && to be modified
\keywords{High Utility Mining, Incremental Mining.}
\end{abstract}


\section{Introduction}
Mining association rule \cite{Agrawal:basic,Agrawal:fast} is a fundamental topic in the data mining applications, especially in market analysis. In association rule mining, frequent pattern mining was firstly proposed to find all itemsets which frequently appear together in the transaction database. With those frequent itemsets, market managers can rearrange their items for promotions or recommend potential commodity for consumers. The initial solution is based on downward closure property , which is a level-wise approach. However, it requires multiple database scans and generates a large number of candidate itemsets to search and identity. Extensive study \cite{Han:FIMwithoutcand} has been proposed to address the problem by introducing frequent pattern (FP) tree structure and corresponding FP-growth algorithm, which is a pattern-growth approach. The main difference between both approaches is whether the database is compressed into other data structure.

However, FP mining results that many frequent but low profitable itemsets come into being and valuable but infrequent ones are missed, of which results cannot be accepted by market makers. The reason is that FP mining treats all items with the same weight, and each item appear in binary form in each transaction without considering its quantity. In fact, weight and quantity are significant for addressing the decision problems in the real world where sellers require maximizing profit/utility from transaction records. Therefore, FP mining cannot satisfy the requirement of mining high profitable itemsets which contribute to the most part of the total profits.

Accordingly, a high utility mining model \cite{Liu:two-phasewithCCPD,Liu:two-phase} was defined to discover high utility patterns from the transaction databases. The significance of itemsets is measured by the concept of utility, which can be represented as weight, profit, cost, quantity or other information depending on the user preference. An itemset is called a high utility itemset if its utility is no less than a user-specified minimum utility threshold. Unlike FP mining, high utility mining involves the databases with profit value of each item, as well as databases with nonbinary frequency values of each item in each transaction record. Therefore, high utility mining more comprehensively represents real world market retail environment. Through utility mining, several business domain decisions like maximizing income or minimizing costs can be resolved. And they can discover knowledge about itemsets which contribute to the majority of the profit.

Moreover, most previous studies \cite{Lin:for-um,Liu:two-phasewithCCPD,Liu:two-phase,Tseng:up-growth} are based on a fixed transaction database and have not taken dynamic increment of database into consideration. In practice, the real markets add their transaction records incrementally, where there are incremental databases instead of fixed ones to be analyzed. If a new transaction records arrive, these approaches should conduct mining procedure anew, which discard previous mining results. Studies \cite{Ahmed:IHUP,Lin:dynamic-databases,Lin:incremental-hui,Yeh:IUM} put their concentration on incremental databases and avoid unnecessary recalculation. However, IUM and FIUM algorithm \cite{Yeh:IUM} mine high temporal utility itemsets. In other words, the utility of these itemsets is high in new added and original database, while it may be not high in the whole database. Though FUP-HU \cite{Lin:dynamic-databases,Lin:incremental-hui} addresses the above shortage, it becomes inefficient especially when the length of high utility pattern is large. That is because the level-wise approach need scan the whole database as the pattern length increases. 

IHUP \cite{Ahmed:IHUP} is a proposed solution for high utility mining in incremental databases. It is based on pattern-growth approach and compresses databases into the IHUP-Tree. Since IHUP maintains the IHUP-Trees with all the items considered, it could add new transactions without reconstruction of the whole pattern tree. However, that is why its efficiency get worse when the number of items in database is relatively large. In fact, the items in high utility itesets are relatively stable when new transactions are added in batch. For that we can just maintain part of whole items and rescan the orignal without rebuilding the pattern tree when necessary.We propose a compressed high utility mining algorithm for incremental databases, which is abbreviated as iCHUM. A headtable maintain fewer potential high utility items, which is compressed as well as corresponding pattern tree. After new transactions are added, we find recalled items from original database of which utility becomes high. The workload is generally light, especially when number of items in the transaction database is huge.

%fill your main work!!!! 
In this paper, we have two main contributions.

First, we propose an efficient algorithm iCHUM for mining high utility itemsets from incremental databases. The algorithm performs better when there are more items in the transaction database.

Second, we conduct a series of experiments with both real and synthetic datasets. We compare the performance between ours and IHUP under incremental databases and analyze the situations where potential high utility items in different proportions of the whole items.

The rest of this paper is organized as follows. In Section 2, we introduce the related work. In Section 3, we propose our pattern structure and algorithm in details after the problem definition. The experimental results and evaluations are shown in Section 4 and the conclusions are give in the Section 5.

\section{Related Work}
\subsection{High Utility Mining}
The formal definition of utility mining problem was give in \cite{Liu:two-phasewithCCPD,Liu:two-phase}, which is similar to what we have adopted. The Two-Phase algorithm was proposed and introduced the concept of transaction-wighted downward closure (TWDC) property , which is an extension of the property in FP mining. The authors have defined transaction-weighted utilization (TWU) and proved that TWU meets the downward closure property. By that, their algorithm finds all the high utility itemsets as a level-wise approach. Firstly, it finds all high TWU 1-itemsets and generates 2-itemset candidates for testing if there exists high TWU 2-itemsets. In that way, it finds all high TWU itemsets level by level, and needs vetifies the candidate to determine the high utility itemsets. This algorithm suffers from multiple scan database scans. To overcome the problem, CTU-Mine \cite{Erwin:CTU} was proposed together with its corresponding CTU-Tree data structure as a pattern-growth approach. The approach scans the database once to build up the pattern structure as compressed transaction database. As candidates for high utility itemsets, high TWU itemsets are formed incrementally from the pattern structure instead of multiple scans of original database. It performs much better in the relatively dense or long pattern databases. Studies \cite{Ahmed:IHUP,Lin:for-um,Tseng:up-growth} have developed the pattern-growth approach to some extend by improving pattern structure and its mining algorithm. However, most pattern structure and its algorithm above are designed for fixed database. It needs reconstruct the whole pattern structure once the database is updated.

%To efficiently generate the HTWUIs and avoid multiple database scan, Ahmed\cite{Ahmed:IHUP} proposed an efficient tree structure, named IHUP-Tree. Each node in IHUP-Tree consists of item name, its support count, and its TWU value. Further, Tseng\cite{Tseng:up-growth} reduce the estimated utility values by applying four strategies. A data structure named UP-Tree is proposed. They discard global unpromising items (DGU) and decrease global node utility (DGN) in construction of a global UP-Tree. The corresponding mining algorithm is called UP-Growth. During the mining process, they discard local unpromising items (DLU) and decrease local node utility (DLN) to enhance the mining performance. Based on \cite{Tseng:up-growth}, Wu\cite{Wu:topK} goes further and proposes TKU algorithm to mine top-K high utility itemsets. They apply five effective strategies not limited to the construction of the tree structure and generation of the candidates. Their strategies span from the period before the construction of the UP-Tree till the accomplishment phase II. The general framework of  \cite{Ahmed:IHUP} \cite{Tseng:up-growth} \cite{Wu:topK} are based on pattern-growth method, which consists of three steps: 1) the construction of the data structure, 2) the generation of the candidates and 3) identification of high utility itemsets, where step 1 and step 2 is phase I and step 3 is phase II. The performance is subject to the whole process including phase I and II. Fewer candidates generated during phase I would reduce the time of identification in phase II. Still their strategies produce too many candidates of high utility itemsets.

\subsection{High Utility Mining in Incremental Databases}
%incremental mining
Researches focus on high utility itemset mining for incremental database are few. Yeh et al. \cite{Yeh:IUM} proposed two methods: incremental utility mining (IUM) algorithm and fast incremental utility mining (FIUM)algorithm. However, these algorithm find high temporal utility itemsets, which is high utility itemsets in the part of the database. When parts joint into the whole, some of high temporal utility itemsets may not be high utiltity ones. Lin et al. \cite{Lin:dynamic-databases,Lin:incremental-hui} proposed an incremental updated HUP maintenance algorithm to address the mining process for incremental databases. It is necessary to find low TWU items back from original database since they may become high ones after the new transactions inserted. They divide the incremental databases into four cases when new transactions are inserted into an original database. What needs to be recalled is that ones with low TWU in original database and high TWU in new database. However, their algorithm is a level-wise approach, of which performance becomes worse when the length of pattern gets longer.

Ahmed \cite{Ahmed:IHUP} proposed their incremental mining method IHUP based on the IHUP-Tree structure. The IHUP-Tree maintains all of the items, and thus it inserts new transaction without rebuilding the tree. All it needs is to maintain the order of the items by TWU thus convenient for mining procedure. Limited to the property of their data structure, the efficiency of the algorithm is not satisfactory when the number of items is large or number of high TWU items is small. On those conditions, IHUP should maintain unnecessary insert or reorder operation for those low utility items. In practice, those changes from low to high are not frequent if we process them by batches.

%introduce our work. find shortcoming of theirs.
%1. new tree structure and mining process
%2. increamental database
Our proposed iCHUM method aims to improve time efficiency by maintaining promising items which may be high utility ones only. When the database grows incrementally, we find back those promising items with low TWU in original database and insert them to our iCHUM-Tree for utility mining without rebuiding the whole pattern structure.

\section{Proposed Method}
%This is my method.
In this section, we first describe the problem definition of the high utility mining. Then, we introduce our framework of the iCHUM which is consisted of data structure and mining algorithm.

\subsection{Problem Definition}
%Definition
We have adopted definitions similar to those in previous works \cite{Ahmed:IHUP,Liu:two-phasewithCCPD,Tseng:up-growth}. Let $ I = \{i_{1},i_{2},\ldots,i_{m}\} $ be a finite item set. Each item has its profit $p(i_{j})$ where $ 1{\leqslant}j{\leqslant}m$. A transaction database $ D = \{T_{1},T_{2},\ldots,T_{n}\} $ is a finite set of transaction records, where each transaction $ T_{s} = \{ {i_{s}}_{1},{i_{s}}_{2},\ldots,{i_{s}}_{t} \} \subseteq I$ where $1{\leqslant}s{\leqslant}n, 1{\leqslant}t{\leqslant}m$. In each transaction $ T_{s} $, each item has its quantity $ q(i_{j},T_{s}) $ where $ 1{\leqslant}j{\leqslant}m$. Let Table~\ref{table:1} be an example of database and Table~\ref{table:2} be an profit table.

An itemset $ X = \{{i_{j}}_{1},{i_{j}}_{2},\ldots,{i_{j}}_{l}\} \subseteq I $, where $ 1{\leqslant}l{\leqslant}m $, and $ l $ is the length of itemset $ X $. If $ \forall i_{j} \in X \cap i_{j} \in T_{s}$, then the itemset $ X \subseteq T_{s} $.

\begin{table}
\begin{minipage}[t]{.45\linewidth}
\centering
\caption{transaction database }
\begin{tabular}{ cc|c|l|c |} 
\cline{3-5} & & \textbf{Tid} & \multicolumn{1}{c|}{\textbf{Transaction}} & \textbf{TU} \\ 
\cline{3-5} 
\cline{3-5} {\multirow{5}{*}{\rotatebox{90}{ $ D0 $}}}& {\multirow{5}{*}{ }} & $ T_{1} $ & (A,5) (B,2) & 9\\ 
\cline{3-5}& & $ T_{2} $ & (A,2) (B,1) (D,1) & 6 \\
\cline{3-5}& & $ T_{3} $ & (E,1) (F,2) & 7 \\
\cline{3-5}& & $ T_{4} $ & (C,3) (D,2) & 13 \\
\cline{3-5}& & $ T_{5} $ & (A,2) (B,2) (C,1) (D,2) & 11 \\
\cline{2-5} {\multirow{3}{*}{\rotatebox{90}{ $ D1 $ }}}& & $ T_{6} $ & (A,3) (B,1) (E,2) & 15\\
\cline{3-5} & & $ T_{7} $ & (B,1) (D,1) (E,1) (F,1) & 10 \\
\cline{3-5} & & $ T_{8} $ & (A,2)  & 2 \\ 
\cline{3-5}
\end{tabular}
\label{table:1}
\end{minipage}
\begin{minipage}[t]{.25\linewidth}
\centering
\caption{Profit table}
\begin{tabular}{|c|c|} \hline
\textbf{Item} & \textbf{Profit} \\ \hline
\textbf{A} & 1 \\ \hline
\textbf{B} & 2 \\ \hline
\textbf{C} & 3\\ \hline
\textbf{D} & 2\\ \hline
\textbf{E} & 5\\ \hline
\textbf{F} & 1\\ \hline
\end{tabular}
\label{table:2}
\end{minipage}
\begin{minipage}[t]{.25\linewidth}
\centering
\caption{TWU table}
\begin{tabular}{|c|c|c|} \hline


\multicolumn{1}{|c}{\multirow{2}[0]{*}{\textbf{Item}}} & \multicolumn{2}{|c|}{\textbf{TWU}} \\
\cline{2-3}\multicolumn{1}{|c|}{} & $ D0 $    & $ D0+D1 $ \\
\cline{1-3}
\textbf{A} & 26& 43\\ \hline
\textbf{B} & 26& 51 \\ \hline
\textbf{C} & 24& 24\\ \hline
\textbf{D} & 30& 40 \\ \hline
\textbf{E} & 7& 32\\ \hline
\textbf{F} & 7& 17\\ \hline
\end{tabular}
\label{table:3}
\end{minipage}

\end{table}

%\newtheorem{theorem}{Definition}
\begin{definition} %[utility of an itemset]
The utility of an itemset $ X $ in the transaction database is denoted as $ U(X) $. 
\begin{equation}
U(X) = \sum_{X \subseteq T_{d} \in D} \sum_{i_{j} \in X} p(i_{j}) \times q(i_{j},T_{d})
\end{equation}
\end{definition}
%\newtheorem{theorem}{Definition}
\begin{definition} %[high Utility mining]
An itemset $ X $ is a high utility itemset if $ U(X) \geqslant min\_util $, where $ min\_util $ represents the utility value user-specified. High utility mining is to find the set of all itemsets $ \mathbf{X} = \{X_{1},X_{2},\ldots,X_{m}\} $ meets the condition $ U(X_{i}) \geqslant min\_util $ for $ \forall X_{i} \in \mathbf{X} $. 
\end{definition}

After we define utility mining problem, we introduce TWU \cite{Liu:two-phase} which helps build up iCHUM-Tree and implement high utility mining algorithm.

\begin{definition} 
The transaction-weighted utility (TWU) of an itemset $ X $ denoted as $ TWU(X) $ is the sum of the transaction utilities (TU) of all transactions containing $ X $. Table~\ref{table:3} records
\begin{equation}
TWU(X) = \sum_{X \subseteq T_{d} \in D}TU(T_{d}) = \sum_{X \subseteq T_{d} \in D} \sum_{i_{j} \in T_{d}} p(i_{j}) \times q(i_{j},T_{d})
\end{equation}
\end{definition}

We can find the relationship that $ U(X) \leqslant TWU(X) $ for $ \forall X $. If an itemset $ X$ whose $ U(X) \geqslant min\_util $, then $ TWU(X) \geqslant min\_util $, which is a high TWU itemset. TWU satisfies downward closure property, which is that for any itemset $ X $ that is not a high TWU itemset, all its supersets are not high TWU itemsets. This is our criterion to generate the candidate for identification.

\subsection{iCHUM Framework}
The framework of iCHUM includes four main procedure, that is iCHUM-Tree construction, iCHUM-Tree update, mining procedure and candidates identifying, shown as Fig.~\ref{fig:framework}. The overall input consists of transaction database and a $ min\_util $, where transaction database includes transaction records and a item profit table. The final output is the set of all high utility itemsets of the transaction database under the $ min\_util $. Actually, for incremental database, we have two parts of transaction database, the original database $ D0 $ and the new database $ D1 $. 

Construction and update of iCHUM-Tree are our main feature procedure. We firstly construct iCHUM-Tree from $ D0 $, and get high utility itemsets following the flow chart. Then, when $ D1 $ comes as an incremental database, update module rearranges the iCHUM-Tree according to the changes $ D1 $ brings to $ D0 $. The updated iCHUM-Tree is to be mined in the same way. The iCHUM-Tree is the input of minig procedure, which produce the candidates set with high TWU. The mining procedure is a pattern-growth mining approach, readers can refer to \cite{Ahmed:IHUP}. Final step of identification is picking up real high utlity itemsets from the candidates set. Thus, we achieve all high utility itemsets of the transaction database, which combines $ D0 $ and $ D1 $ as a whole.

\begin{figure}
\centering
\begin{minipage}[b]{0.4\textwidth}
\centering
\includegraphics[width=0.78\linewidth, scale=0.1]{./b.eps}
\caption{Framework of iCHUM}
\label{fig:framework}
\end{minipage}
\begin{minipage}[b]{0.56\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{./all.eps}
\caption{Construction and update of iCHUM-Tree (a) after inserting $ T_{5} $, (b) after inserting $ T_{8} $}
\label{fig:tree}
\end{minipage}
\end{figure}

\subsection{iCHUM-Tree Construction and Update}
%Data structure
Our iCHUM-Tree consists of tree structure and its headtable $ H $ for traversal, shown in Fig.~\ref{fig:tree}a. In iCHUM-Tree, The nodes in the trees includes name, TWU, count, parent node, brother node and a set of child nodes, expressed as $ \{ name\}:(count, TWU) $. In headtable, each entry consists of the item name, TWU and a link pointed to nodes with the same name in the iCHUM-Tree. 

\textbf{Construction of iCHUM-Tree} is to constrcut iCHUM-Tree from the original database, shown in Algorithm~\ref{alg:construct}. According to TWDC property, the items with low TWU cannot appear in high utility itemsets. Therefore, the headtable of iCHUM-Tree simply maintains the promising items with TWU $ \geqslant min\_util $, which make up the nodes of iCHUM-Tree. Before each transaction record is inserted to the tree, we arrange the items in desceding order. It is because that it is efficient for mining procedure when traversing braches from bottom to top. When mining process enters entry of higher TWU item, it would not turn back to look up those low TWU items. During insertion if an item has been existed, we add its count by one and its TWU by TU of current transaction. Therefore, each brach of the iCHUM represents possible itemsets appeared in transaction records inserted.

\begin{algorithm}
\caption{iCHUM-Tree Construction}
\begin{algorithmic}
\REQUIRE  $ D0 $ ,  $ min\_util $
\ENSURE  $ TWU $ , iCHUM-Tree, $ H $
\STATE{\textbf{scan} \textit{D0} to update $ TWU $ }
\STATE{\textbf{Create } $ H $ for each $ i $ satisfying $ TWU[i] \geqslant min\_util $ in $ TWU $ descending order }
\STATE{}
\COMMENT{ /* The following is \textbf{scan} and \textbf{insert} process */}
\FOR{each $ T_{d} $ in $ D0 $ }
\STATE{\textbf{sort} $ T_{d} $ to $ T_{d}' $ in $ TWU $ descending order }
\FOR{each i in $ T_{d}'$  }
\IF{i $ \in H $ }
\STATE{\textbf{insert} i to iCHUM-Tree }
\ENDIF
\ENDFOR
\ENDFOR
\end{algorithmic}
\label{alg:construct}
\end{algorithm}

\textbf{Update of iCHUM-Tree} is performed when new transaction database comes to be inserted based on original database, shown in Algorithm~\ref{alg:update}. In new database, there would exists such items which is promising in the new one but not in the original. Even, these items, called recalled items, may become promising in the whole database, such as E in Fig.~\ref{fig:tree}b. In this case, iCHUM need to find back recalled items from $ D0 $, and insert them to $ H $ and iCHUM-Tree.  The bubble sort operation of headtable and iCHUM-Tree is based on TWU. Each swap operation starts from entry in $ H $ ,and exchange both iCHUM-Tree nodes if they are a pair of parent and child nodes.

Let us give an example of the construction and update procedure. Considering $ D0 $ in Table~\ref{table:1}, we set the $ min\_util $ as 40\% of the sum of TU, which is 18.4. $ H $ is created with items of which TWU $ \geqslant $ 18.4. The promising items are ``D A B C'' in TWU descending order. We insert these items in each transaction by the order and formulate iCHUM-Tree in Fig.~\ref{fig:tree}a. When $ D1 $ comes, TWU of items changes and $ min\_util $ is 29.2. We insert the recalled item E to the headtable and tree with the previous order. And we keep the umpromising item C because it had once been high TWU items. It is more likely that it becomes high TWU item again as more transaction records are inserted. We get bubble-sorted iCHUM-Tree and its headtable for mining procedure. 

\begin{algorithm}
\caption{iCHUM-Tree Update}
\label{alg:update}
\begin{algorithmic}
\REQUIRE $ D0 $ , $ D1 $ ,  $ min\_util $ ,$ TWU $, iCHUM-Tree of $ D0 $, $ H $ of $ D0 $
\ENSURE  updated iCHUM-Tree, updated $ H $
\STATE{\textbf{scan} $ D1 $ to update $ TWU $ and find recalled items $ I' $ }
\FOR{each i$ '  \in I' $  }
\STATE{\textbf{Add} i$ ' $ to $ H $  }
\ENDFOR
\STATE{\textbf{scan} $ D0 $ and \textbf{insert} i$ ' $ to iCHUM-Tree  }
\STATE{\textbf{scan} $ D1 $ and \textbf{insert} i $ \in H $ to iCHUM-Tree  }
\STATE{\textbf{update} $ H $ and iCHUM-Tree by bubble sort operation }

\end{algorithmic}
\end{algorithm}

\section{Experimental Evaluation}
%my experiment and evaluation
In this section, we evaluate the performance of iCHUM algorithm written in C++. The experiment were conducted on Ubuntu server with a dual-2.4GHz CPU processor and 4G memory. Both real and synthetic dataset could be obtained from NU-MineBench \footnote{http://cucis.ece.northwestern.edu/projects/DMS/MineBench.html}. Real dataset, named \textit{Chainstore}, is a sparse and large database. It contains 1,112,949 transaction records and total 46,086 kinds of items. We split the database into $ D0 $ of 700,000 and $ D1 $ of 412,949. Synthetic dataset, named T10I6D100, contains 100 items and 93,058 transaction records of which average length is 10. The database is divided into $ D0 $ of 60,000 and $ D1 $ of 33,058.

As a comparison, we implement IHUP algorithm and a iCHUM brute force (iCHUM-BF) algorithm in C++ as baseline. The iCHUM-BF algorithm is mining iCHUM-Tree twice without update procedure regarding the $ D0 $ and $ D0+D1 $ as original database input respectively.

\begin{figure}
\centering
\begin{minipage}[b]{0.48\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{./e2.eps}
\caption{Runtime on T10I6D100}
\label{fig:synthetic}
\end{minipage}
\begin{minipage}[b]{0.48\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{./e1.eps}
\caption{Runtime on Chainstore}
\label{fig:real}
\end{minipage}
\end{figure}

Fig.~\ref{fig:synthetic} shows the execution runtime on synthetic T10I6D100. For larger $ min\_util $ or minimum utility, runtime of iCHUM is less on construction and update of tree structure, shown in Table~\ref{table:4}. Howerver, performace of iCHUM becomes worse with respect to IHUP. It is because that the number of items with high TWU reaches close to the total number of items. The cost of maintaining headtable is almost the same. Besides, iCHUM should spend more time on finding back recalled items. Nevertheless, iCHUM and IHUP run with the same efficiency when the TWU of all items is high. That happens in such a dataset, where there are fewer items and transaction length is longer. The iCHUM has an advantage over IHUP on sparse transacation database, shown as Fig.~\ref{fig:real} and Table~\ref{table:4}. Each item accounts for small proportion of whole transaction, where maintaining headtable with high TWU items is efficient. 



\begin{table}
\centering
\caption{Runtime Distribution (sec.) of iCHUM and IHUP}
\begin{tabular}{c*{7}{c}r}
\hline
\multirow{2}[0]{*}{Dataset}  & \multicolumn{1}{c}{\multirow{2}[0]{*}{Algorithm}}  & \multicolumn{3}{c}{D0}  &\multicolumn{3}{c}{D1}  & \multicolumn{1}{c}{\multirow{2}[0]{*}{Time}} \\
 & \multicolumn{1}{c}{}  & construction & mining& identifying  & update & mining  & identifying & \multicolumn{1}{c}{}  \\
\hline
T10I6D100   & IHUP &  33.89 &  0.27     & 0.07  &    67.40   & 0.42      &  0.22     & 102.27 \\
$  0.5 \% $ & iCHUM &   30.60    &   0.26    &   0.07   &  62.64     &   0.41    &    0.22   & 94.20 \\
\hline
Chainstore & IHUP   &   209.14    &   1.45   &    46.09   &   318.78    &   2.29   &   73.86    & 651.61 \\
$ 0.2 \% $ & iCHUM &   113.98    &  1.33      &  46.00     &  199.74     &   2.18    &  72.63     & 435.86 \\
\hline
\end{tabular}
\label{table:4}
\end{table}


\section{Conclusions}
In this paper, we propose an efficient algorithm iCHUM for mining high utility itemsets in incremental databases. The iCHUM-Tree compress transaction database into compact tree structure. The update of iCHUM-Tree maintain list of all high TWU items which guarantee find all high utility itemsets. Experiment analysis shows that iCHUM-Tree performs better than other baseline in the databases, especially for those in terms of large number of transaction records or items. 

%\end{document}  % This is where a 'short' article might terminate

%ACKNOWLEDGMENTS are optional
%\section*{Acknowledgments}
%The authors would like to gratitude to Berkin Ozisikyilmaz from Northwestern University. His useful help largely contribute to our dataset making.


\bibliographystyle{abbrv}
\bibliography{sigproc}

\end{document}
